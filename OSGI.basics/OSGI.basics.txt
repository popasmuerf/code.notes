1. Introduction into Software modularity with OSGi
1.1  What is software modularity?
An application consists of different parts, these are typically called
software components of software modules.

These components interact with each other via  an API.
APIs are generally a set of classes and methods which can be used
from other components.

A component also has a set of classes and methods which are
considered as internal to the software component.

If a component uses an API from another component, it has
a dependnecy to the other component, i.e., it requires
the other component exists and works correctly.


A component which is used by other components shopuld try to keep its API
stable to avoid that a change affects other components.
But it should be free to change its internal implementation.


Java, in it's current version(Java 8), provides no structured way to
describe software component dependencies.
Java only supports the usage of access modifiers, but every public
lass can be called from another software component.  What is desired
is a way to explicityly define the API of a sofware component.
The OSGi specification fills this gap.


1.2 What is OSGi ?
OSGi is a set of specfications which, in its core specfication,
defines a component and service model for Java.
A practical advantage of OSGi is that every software comoponent can
define its API via a set of exported Java packages and that every
component can specify its required dependencies.

The components and services can e dynamically installed, de-activated,
updated and de-installed.

1.3 OSGi implementations
The OSGi specfication  has several implementations, for example:
	*Eclipse Equinox
	*Knopflerfish OSGi
	*Apache Felix
Eclipse Equinox is the reference implementation of the base OSGi specfication.
It is also the runtime enviroment on which Eclipse applications are based.



1.4  Plug-in or bundles as software component

The OSGi specfication defines a bundle as the smalles unit of modularization,i.e, in
OSGi, a software component is a bundle.  The Eclipse programming model typcially
calls them plug-in but these terms are interchangable.  A Val;id plug-in is always
a valid bundle and a valid bundle is always a valid plug-in

A plug-in is a cohesive, self-contained unit, which explicity defines its dependencies to other
components and services.  It also defines its API via Java packages.


1.5 Naming convention: simple plug-in

A plug-in can be generated by Eclipse via the workflow:
	File--> Other...-->Plug-In Development --> Plug-in Project menu entry.
The corresponding  wizard allows specifying several options.  This book calls
plug-ins generated with the following options a simple plug-in or simple bundle


2.1. The manifest file(MANIFEST)

Technically OSGi plug-ins are .jar files with addtional meta information.  This meta
information is stored in the:
	META-INF/MANIFEST.MF file.
This file is called the manifest file and is part of the of the standard Java specfication
and OSGi adds additonal metadata to it.  According to the Java sprecfication, any
Java runtime must ignore unkown metadata...Therefore, p;lugins can be used without
restrictions in other Java enviroments:

Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: Popup Plug-in
Bundle-SymbolicName: com.example.myosgi; singleton:=true
Bundle-Version: 1.0.0
Bundle-Activator: com.example.myosgi.Activator
Require-Bundle: org.eclipse.ui,
 org.eclipse.core.runtime
Bundle-ActivationPolicy: lazy
Bundle-RequiredExecutionEnvironment: JavaSE-1.6


OSGI Identifiers in the manifest file

Bundle-Name:
	Short description of the plug-in
Bundle-SympolicName:
	The unique identifier of the plug-in is using the extension
	point functionality of Eclipse.  It must be marked as Singleton.
	You do this by adding the following statement after the Bundle-SymbolicName
	identifier:
	; singleton:=true
Bundle-Version:
	Defines the plug-in version and must be incremented if a new version
	of the plug-in is published
Bundle-Activator:
	Defines an optional activator interface.  An instance of this class
	is created when the plug-in gets activated.  It's methods:
		start() ;
		stop() ;
	are called wheenver the plug-in is stared or stopped.
	OSGi Bundle-Activators are used often for to the configure
	the plug-in during startup.  The execution of an 
	activator increases the startup time of the application, therefore
	this functionality shold be used carefully and sparringly.
Bundle-RequiredExecutionEnviroment(BREE):
	Specify which java version is required to run the plug-in.  If this
	requirement is not fullfilled, then the OSGi runtime does not 
	load the plug-in.

	

