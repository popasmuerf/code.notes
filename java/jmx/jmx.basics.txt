https://www.journaldev.com/1352/what-is-jmx-mbean-jconsole-tutorial

What is JMX ?
=================================
*	JMX = Java Management Extensions(JMX)
*	Introduced in J2SE 5.0
*	Provides architecture to manage
	resources dynamically at runtime.
*	Used mostly in enterprise applications
	to make the system configurable 
	or to get the state of 
	application at any point of time.


Managed Beans
===================================
*	Resources managed via JMX are
	done so via:
		-Managed Beans(MBeans)
*	Managed Beans are registered
	to a MBeans Server
*	MBean servers work as a management
	agent for all MBeans registered.

*	JMX connectors are used to connect
	to MBean server and to manage
	the regiserd resources.

*	JDK provides:
		- JConsole:
			* which may be used to 
			  to connect to any local
			  or remote MBean server.
*	Most widely used servers such as:
		-JBoss
		-WebSphere
	comes with JMX Console to monitor
	and manage MBeans


Rules of creating MBeans
======================================
*	The interface name must end with "Bean"

//Code example
----------------------------------
public interface SystemConfigBean {
	public void setThreadCount(int nOfThread);
	public int getThreadCount() ;
	public void setSchemaName(String schemaName);
	public String getSchemaName();
	//any methd starting with get and set
	//are conscidered as attributes getter and setter
	//methods, so I am using do* for operation

	public String doConfig() ;
}


public class SystemConfig implements SystemsConfigMBrean{
	private int threadCount ;
	private String schemaName ;

	//....Implementation....//
	//....
	///....

}

/**
 * Code Example fo 
 */
public class JavaPongActor extends AbstractActor{
    private final LoggingAdapter log = Logging.getLogger(getContext().getSystem(),this);
    @Override
    public Receive createReceive() {
        Receive builtReceiver = receiveBuilder()
                .match(String.class, s -> {
                    log.info("Recieved String message: {}", s);
                } ).matchEquals("Ping",s -> respondToPing(s))
                .matchEquals("Ping",s ->
                sender().tell("Pong", ActorRef.noSender()))
                .matchAny(o -> log.info("received uknown message"))
                .build();
        return null ;
    }
}



^^^
inherited Abstract Classes
===========================
AbstractActor(Abstract class)
---------------------------
	*	specific API that is meant to take
	advantage of the Java8 lambda features.
	*	There exists an older base aActor API that 
	can be used for Java if you look at the
	documentation --> UntypedActor
		-	use if statements to match
			on the object.
		-	less expressive than the Java 8 API
			as the Java 8 API allows for pattern
			matching via lambdas

Recieve()
---------------------------
	*	Abstract method --> AbstractActor.Recieve()
	*	Returns type : PartialFunction
	*	There is no native way to building a 
		a type PartialFunction because it is a
		Scala type.
	*	A PartialFunction is a function type
		that only matches some inputs but not
		all

	*	Scala provides a builder abstraction
		for production of the PartialFunction
		called --> RecieveBuilder

//Code for Reciever
public class JavaPongActor extends AbstractorActor{
	......
	@Override
	public Recieve createRecieve(){
		......
	}
}

RecieveBuilder
---------------------------
	*	We cal RecieveBilder methods, 



Available methods
=======================

Pipeline health
===============================
0. Health of Message Producer
	1.2
1. Health of each step of ingestion:
	1.1 Ingest rate to the parser
	1.2 Ingest rate into the database
	1
rabbitmq.fractal


